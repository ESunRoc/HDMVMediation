---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}
library(MSGLasso); library(matrixcalc); library(dplyr); 
library(mvtnorm); library(glmnet); library(MASS); library(doParallel)

source("/Users/elisunorig/Desktop/All the Things/Grad School/Research/HD Mediation:Outcomes/Simulations/Testing full method/MultivarMediationSimFunctions.R")
```

```{r}
sim_sett <- list(n=100, p=25, p0=5, l=5, k=5, q=1, corr = "high"); nsim <- 500; nB <- 5e3; alpha <- 0.05

# BootSim <- function(sim_sett, nsim = 500, nB = 5e3, alpha = 0.05){
q <- sim_sett$q; p <- sim_sett$p; p0 <- sim_sett$p0; n <- sim_sett$n; 
k <- sim_sett$k; l <- sim_sett$l; corr <- sim_sett$corr

results <- list("data_genSeeds"  = (1:nsim)^2+(1:nsim),
                "true_coefs"     = matrix(nrow = k*p, ncol = nsim),
                "orig_coefs"     = matrix(nrow = k*p+q*k, ncol = nsim),
                "Boot_Draws"     = matrix(nrow = n, ncol= nB*nsim),
                "Boot_Coefs"     = matrix(ncol = nB*nsim, nrow = k*p+q*k),
                "pvals"          = matrix(ncol = nsim, nrow = k*p+q*k),
                "bca_ints_lower" = matrix(ncol = nsim, nrow = k*p+q*k),
                "bca_ints_upper" = matrix(ncol = nsim, nrow = k*p+q*k),
                "piv_ints_lower" = matrix(ncol = nsim, nrow = k*p+q*k),
                "piv_ints_upper" = matrix(ncol = nsim, nrow = k*p+q*k))


for(sim in 1:nsim){
  #### Generate data ####
  orig_data <- gen_data(n = n, p = p, p0 = p0, l = l, q = q, k = k, seed = sim^2+sim, corr = corr, quiet = T, b_scale = 2)
  
  X <- orig_data$data$X; M <- orig_data$data$M; 
  U <- orig_data$data$U; Y <- orig_data$data$Y
  
  
  #### Stage 1 model ####
  stage1_mod_TrtToMedi <- lm(M ~ X + U)
  stage1_TrtToMedi_summ <- broom::tidy(stage1_mod_TrtToMedi)
  
  stage1_coefs <- stage1_TrtToMedi_summ[which(stage1_TrtToMedi_summ$term=="X"),]
  
  #### Stage 2 model ####
  P <- p + l + q
  Q <- k
  
  G <- p + 2 # Groups on X: p + 2; p mediator singleton groups + 1 confounder group + 1 treatment group
  if(k == 5){R<-4} else {R<-7} # Groups on Y: {(1,2),(3),(4),(5)} or {(1,2,3),(4,5),(6),(7),(8),(9),(10)}
  
  gmax <- 1 # each variable (resp or pred) belongs to only 1 group
  cmax <- l # a group contains at most l variables (confounders form largest group)
  
  GarrStarts <- c(0:(p-1), p,  p+l+1)
  GarrEnds <-   c(0:(p-1), p+l, p+l+2)
  
  if(k == 5){
    RarrStarts <- c(0,2,3,4); RarrEnds   <- c(1,2,3,4) 
  } else{
    RarrStarts <- c(0,3,5,6,7,8,9);  RarrEnds   <- c(2,4,5,6,7,8,9) 
  }
  
  tmp_PQgrps <- FindingPQGrps(P = P, Q = Q, G, R, gmax, GarrStarts, GarrEnds, RarrStarts, RarrEnds)
  PQgrps <- tmp_PQgrps$PQgrps
  
  tmp_grpWts <- Cal_grpWTs(P = P, Q = Q, G, R, gmax, PQgrps)
  grpWTs <- tmp_grpWts$grpWTs
  
  tmp_GRgrps <- FindingGRGrps(P = P, Q = Q, G, R, cmax, GarrStarts, GarrEnds, RarrStarts, RarrEnds)
  GRgrps <- tmp_GRgrps$GRgrps
  
  
  Pen_L <- matrix(rep(1, P*Q), P, Q, byrow=T)
  Pen_L[(p+1):P,] <- 0 # don't penalize the confounders, (p+1):(P-1), or treatment, P
  
  Pen_G <- matrix(rep(1,G*R),G,R, byrow=TRUE)
  Pen_G[(G-1):G,] <- 0 # don't penalize confounder group, G-1, or treatment group, G
  
  grp_Norm0 <- matrix(rep(1, G*R), nrow=G, byrow=TRUE)
  
  
  lam1.v <- seq(1e-5, 0.05, length=15)
  lamG.v <- seq(1e-5, 0.05, length=15)
  
  invisible(capture.output(step2_try_cv <- MSGLasso.cv(X = cbind(M,U,X), Y = Y,
                                                      grpWTs, Pen_L, Pen_G,
                                                      PQgrps, GRgrps, lam1.v, lamG.v,
                                                      fold = 5, seed = 7^7)))
  
  
  MSGLassolam1 <- step2_try_cv$lams.c[which.min(as.vector(step2_try_cv$rss.cv))][[1]]$lam1
  MSGLassolamG <- step2_try_cv$lams.c[which.min(as.vector(step2_try_cv$rss.cv))][[1]]$lam3
  MSGLassolamG.m <- matrix(rep(MSGLassolamG, G*R),G,R,byrow=TRUE)
  MSGLassolamG.m[(G-1):G,] <- 0
  
  
  stage2_mod <- MSGLasso(X.m = cbind(M, U, X), Y.m = Y,
                         grpWTs, Pen_L, Pen_G, PQgrps, GRgrps,
                         grp_Norm0, MSGLassolam1, MSGLassolamG.m)
  
  
  
  stage2_mod_selected <- stage2_mod$Beta
  rownames(stage2_mod_selected) <- colnames(cbind(M, U, X))
  colnames(stage2_mod_selected) <- colnames(Y)
  
  
  #### Extract originally estimated effects ####
  mod_DE <- stage2_mod_selected["X1",]
  
  stage2_mod_pide <- stage2_mod_selected[1:p,]
  stage1_mod_pide <- stage1_coefs$estimate
  
  mod_pide_mat <- matrix(nrow = p, ncol = k)
  for(i in 1:k) mod_pide_mat[,i] <-   stage1_mod_pide*stage2_mod_pide[,i]
  
  rownames(mod_pide_mat) <- rownames(stage2_mod_selected)[1:p]; colnames(mod_pide_mat) <- colnames(stage2_mod_selected)
  mod_tide_mat <- colSums(mod_pide_mat)
  
  mod_origFit_mat <- matrix(nrow = p*k+2*k, ncol = 1)
  mod_origFit_mat[,1] <- c(vec(mod_pide_mat),unname(mod_tide_mat),unname(mod_DE))
  rownames(mod_origFit_mat) <- c(paste0(rownames(mod_pide_mat),"_ide_resp",rep(1:k, times = rep(p,k))),
                                  paste0("TIDE_resp",1:k),
                                  paste0("DE_resp", 1:k))
  colnames(mod_origFit_mat) <- "Orig_Est"
  
  
  #### Calculate the true PIDEs ####
  true_pides_mat <- matrix(nrow = p, ncol = k)
  for(i in 1:k) true_pides_mat[,i] <- orig_data$parameters$`True A_mat`[l+1,] * orig_data$parameters$`True B_mat`[1:p,i]
  
  
  
  #### Bootstrap inference ####
  B_draws <- matrix(nrow = n, ncol = nB)
  for(i in 1:nB) {set.seed((i+1)^1); B_draws[,i] <- sample(1:n, n, replace=T)}
  
  mod_bootRes <- matrix(nrow = p*k+2*k, ncol = nB)
  rownames(mod_bootRes) <- c(paste0(rownames(mod_pide_mat),"_ide_resp",rep(1:k, times = rep(p,k))),
                              paste0("TIDE_resp",1:k),
                              paste0("DE_resp", 1:k))
  colnames(mod_bootRes) <- paste0("BootDraw",1:nB)
  
  start_time <- proc.time()
  for(i in 1:nB){
    ## Stage 1 fit
    U_boot <- U[B_draws[,i],]
    X_boot <- X[B_draws[,i]]
    M_boot <- M[B_draws[,i],]
    Y_boot <- Y[B_draws[,i],]
    
    mod_stage1_boot_fit <- lm(M_boot ~ X_boot + U_boot)
    mod_stage1_boot_tidy <- broom::tidy(mod_stage1_boot_fit)
    mod_stage1 <- mod_stage1_boot_tidy[which(mod_stage1_boot_tidy$term=="X_boot"),]
    
    
    ## Stage 2 fit
    mod_stage2_boot_fit <- MSGLasso(X.m = cbind(M_boot, U_boot, X_boot),
                                     Y.m = Y_boot,
                                     grpWTs, Pen_L, Pen_G, PQgrps, GRgrps,
                                     grp_Norm0, MSGLassolam1, MSGLassolamG.m)
    mod_stage2_boot_selected <- mod_stage2_boot_fit$Beta
    rownames(mod_stage2_boot_selected) <- colnames(cbind(M_boot, U_boot, X_boot))
    colnames(mod_stage2_boot_selected) <- colnames(Y_boot)
    
    ## PIDE and DE calculation
    mod_boot_DE <- unname(mod_stage2_boot_selected["X_boot",])
    
    mod_stage2_pide_boot <- mod_stage2_boot_selected[1:p,]
    mod_stage1_pide_boot <- mod_stage1$estimate
    
    mod_pide_mat_boot <- matrix(nrow = p, ncol = k)
    for(j in 1:k) mod_pide_mat_boot[,j] <- mod_stage1_pide_boot*mod_stage2_pide_boot[,j]
    
    mod_tide_mat_boot <- colSums(mod_pide_mat_boot)
    
    mod_bootRes[,i] <- c(vec(mod_pide_mat_boot),mod_tide_mat_boot,mod_boot_DE)
    
    if(i %% 1000 == 0){
      cat(paste0("Done with boot sample ", i, "; ", nB-i, " remaining. Time elapsed: ",
                 round(-1*(start_time[3] - proc.time()[3])/60, 3), " minutes. Apx. ",
                 round(((-1*(start_time[3] - proc.time()[3])/60)/i)*(nB-i), 3), " minutes remaining\n"))
    }
  }
  
  mod_bootRes <- ifelse(is.nan(mod_bootRes),0,mod_bootRes)
  
  ## bootstrap p-values
  mod_boot_pvals <- matrix(nrow=p*k+2*k, ncol = 1)
  for( i in 1:nrow(mod_bootRes)){
    if(mod_origFit_mat[i,] >= 0){
      mod_boot_pvals[i,] <- min(2*sum(mod_bootRes[i,]>=2*mod_origFit_mat[i,],na.rm=T)/nB,1)
    } else{
      mod_boot_pvals[i,] <- min(2*sum(mod_bootRes[i,]<2*mod_origFit_mat[i,],na.rm=T)/nB,1)
    }
  }
  
  mod_boot_bcaCI <- t(apply(mod_bootRes, 1, coxed::bca))
  mod_boot_bcaCI[is.nan(mod_boot_bcaCI)] <- 0
  
  ## pivotal bootstrap CIs
  mod_boot_pivCI <- 2*matrix(data = c(mod_origFit_mat, mod_origFit_mat), ncol = 2) - t(apply(mod_bootRes, 1, quantile, c(1-alpha/2,alpha/2)))
  
  ## Summary table
  mod_boot_summ <- cbind(mod_origFit_mat, apply(mod_bootRes,1,mean), 
                                mod_boot_pvals, mod_boot_bcaCI, mod_boot_pivCI)
  colnames(mod_boot_summ) <- c("OrigEst", "Mean_boot", "boot_pval",
                                 "bca_lowerCL", "bca_upperCL",
                                 "piv_lowerCL", "piv_upperCL")
  mod_boot_summ[is.nan(mod_boot_summ)] <- 0
  
  
  #### Store results ####
  results$orig_coefs[,sim]     <- mod_origFit_mat[c(1:(p*k),(p*k+k+1):(p*k+2*k)),]; 
  rownames(results$orig_coefs) <- rownames(mod_origFit_mat)[c(1:(p*k),(p*k+k+1):(p*k+2*k))]
  results$true_coefs[,sim]     <- vec(true_pides_mat)
  results$Boot_Coefs[,sim]     <- mod_boot_summ[c(1:(p*k), (p*k+k+1):(p*k+2*k)),2]
  results$pvals[,sim]          <- mod_boot_summ[c(1:(p*k), (p*k+k+1):(p*k+2*k)),3]
  results$bca_ints_lower[,sim] <- mod_boot_summ[c(1:(p*k), (p*k+k+1):(p*k+2*k)),4]
  results$bca_ints_upper[,sim] <- mod_boot_summ[c(1:(p*k), (p*k+k+1):(p*k+2*k)),5]
  results$piv_ints_lower[,sim] <- mod_boot_summ[c(1:(p*k), (p*k+k+1):(p*k+2*k)),6]
  results$piv_ints_upper[,sim] <- mod_boot_summ[c(1:(p*k), (p*k+k+1):(p*k+2*k)),7]
  
  if(sim %% 5 == 0){
  cat(paste0("Done with sim ", sim, "; ", nsim-sim, " remaining. Time elapsed: ", 
                 round(-1*(start_time[3] - proc.time()[3])/60, 3), " minutes. Apx. ",
                 round(((-1*(start_time[3] - proc.time()[3])/60)/sim)*(nsim-sim), 3), " minutes remaining\n"))
  }
}
# }
```

